<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">

  
  <meta name="author" content="author">

  
  
  <meta name="description" content="概述 线性查找分为顺序查找和二分查找。 查找有两种形态，破坏性查找和非破坏性查找，非破坏性查找不会改变数据结构。 顺序查找 思想 从头到尾顺序遍历一遍">
  

  
  <link rel="icon" href="https://mwflower.github.io/favicon.ico">

  
  

  
  

  
  <meta property="og:title" content="经典查找算法" />
<meta property="og:description" content="概述 线性查找分为顺序查找和二分查找。 查找有两种形态，破坏性查找和非破坏性查找，非破坏性查找不会改变数据结构。 顺序查找 思想 从头到尾顺序遍历一遍" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://mwflower.github.io/post/class-find-algorithm/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2019-08-06T00:00:00+08:00" />
<meta property="article:modified_time" content="2019-08-06T00:00:00+08:00" />


  
  <link rel="canonical" href="https://mwflower.github.io/post/class-find-algorithm/">

  
  
  <meta itemprop="name" content="经典查找算法">
<meta itemprop="description" content="概述 线性查找分为顺序查找和二分查找。 查找有两种形态，破坏性查找和非破坏性查找，非破坏性查找不会改变数据结构。 顺序查找 思想 从头到尾顺序遍历一遍"><meta itemprop="datePublished" content="2019-08-06T00:00:00+08:00" />
<meta itemprop="dateModified" content="2019-08-06T00:00:00+08:00" />
<meta itemprop="wordCount" content="1459">
<meta itemprop="keywords" content="draft," />

  
  <link media="screen" rel="stylesheet" href='https://mwflower.github.io/css/common.css'>
  <link media="screen" rel="stylesheet" href='https://mwflower.github.io/css/content.css'>

  
  
  <title>经典查找算法 - Run</title>
  

  
  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="经典查找算法"/>
<meta name="twitter:description" content="概述 线性查找分为顺序查找和二分查找。 查找有两种形态，破坏性查找和非破坏性查找，非破坏性查找不会改变数据结构。 顺序查找 思想 从头到尾顺序遍历一遍"/>


  
<link rel="stylesheet" href='https://mwflower.github.io/css/single.css'>

</head>

<body>
  <div id="wrapper">
    <header id="header">
  <h1>
    <a href="https://mwflower.github.io/">Run</a>
  </h1>

</header>

    
<main id="main" class="post">
  
  
  <h1>经典查找算法</h1>
  
  
  
  
  
  <details>
    <summary>
      <b>Table of Contents</b>
    </summary>
    <div class="toc"><nav id="TableOfContents">
  <ul>
    <li><a href="#思想">思想</a></li>
  </ul>

  <ul>
    <li><a href="#思想-1">思想</a></li>
    <li><a href="#实现">实现</a></li>
    <li><a href="#分析">分析</a></li>
  </ul>

  <ul>
    <li><a href="#思想-2">思想</a></li>
    <li><a href="#实现-1">实现</a></li>
    <li><a href="#分析-1">分析</a></li>
  </ul>

  <ul>
    <li><a href="#思想-3">思想</a></li>
    <li><a href="#实现-2">实现</a>
      <ul>
        <li><a href="#todo">TODO</a></li>
      </ul>
    </li>
    <li><a href="#分析-2">分析</a></li>
  </ul>

  <ul>
    <li><a href="#思想-4">思想</a>
      <ul>
        <li><a href="#插入数据">插入数据</a></li>
        <li><a href="#查找数据">查找数据</a></li>
        <li><a href="#删除数据">删除数据</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
  </details>
  
  
  <article class="content">
    
    <h1 id="概述">概述</h1>
<p>线性查找分为顺序查找和二分查找。<br>
查找有两种形态，破坏性查找和非破坏性查找，非破坏性查找不会改变数据结构。</p>
<h1 id="顺序查找">顺序查找</h1>
<h2 id="思想">思想</h2>
<p>从头到尾顺序遍历一遍，很简单直接的方法。</p>
<h1 id="二分查找">二分查找</h1>
<h2 id="思想-1">思想</h2>
<p>假设一个从小到大的有序序列，取中间值和目标比较，如果中间值大，则下一步比较中间值之前的序列，否则比较中间值之后的序列。依次循环，直到找到目标值或遍历结束。</p>
<h2 id="实现">实现</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">def</span> <span style="color:#00a000">bin_search</span>(arr, key):  
</span></span><span style="display:flex;"><span>    low, high <span style="color:#666">=</span> <span style="color:#666">0</span>, <span style="color:#a2f">len</span>(arr) <span style="color:#666">-</span> <span style="color:#666">1</span>  
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">while</span> low <span style="color:#666">&lt;</span> high:  
</span></span><span style="display:flex;"><span>        mid <span style="color:#666">=</span> (low <span style="color:#666">+</span> high) <span style="color:#666">/</span> <span style="color:#666">2</span>  
</span></span><span style="display:flex;"><span>        <span style="color:#a2f">print</span>(<span style="color:#b44">&#34;mid = </span><span style="color:#b68;font-weight:bold">{mid}</span><span style="color:#b44">, low = </span><span style="color:#b68;font-weight:bold">{low}</span><span style="color:#b44">, high = </span><span style="color:#b68;font-weight:bold">{high}</span><span style="color:#b44">&#34;</span><span style="color:#666">.</span>format(mid <span style="color:#666">=</span> mid, low <span style="color:#666">=</span> low, high <span style="color:#666">=</span> high))  
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span> key <span style="color:#666">&lt;</span> arr[mid]:  
</span></span><span style="display:flex;"><span>            high <span style="color:#666">=</span> mid <span style="color:#666">-</span> <span style="color:#666">1</span>  
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">elif</span> key <span style="color:#666">&gt;</span> arr[mid]:  
</span></span><span style="display:flex;"><span>            low <span style="color:#666">=</span> mid <span style="color:#666">+</span> <span style="color:#666">1</span>  
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">else</span>:  
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">return</span> mid  
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span> key <span style="color:#666">&lt;</span> arr[low] <span style="color:#a2f;font-weight:bold">or</span> key <span style="color:#666">&gt;</span> arr[high]:  
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">break</span>  
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f;font-weight:bold">None</span>  
</span></span></code></pre></div><h2 id="分析">分析</h2>
<p>有序序列时间复杂度为O(nlogn)；<br>
无序序列时间复杂度为排序+查找=O(nlogn)+O(nlogn)，最快的排序算法时间复杂度为O(nlogn)；<br>
只适用于线性结构的数据。</p>
<h1 id="插值查找">插值查找</h1>
<h2 id="思想-2">思想</h2>
<p>核心在于插值的计算公式 (key-a[low])/(a[high]-a[low])*(high-low)。<br>
基于二分查找，将查找点的选择改进为自适应选择，可以提高查找效率，也属于有序查找。<br>
对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。</p>
<h2 id="实现-1">实现</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">def</span> <span style="color:#00a000">insert_search</span>(arr, key):  
</span></span><span style="display:flex;"><span>    low, high <span style="color:#666">=</span> <span style="color:#666">0</span>, <span style="color:#a2f">len</span>(arr) <span style="color:#666">-</span> <span style="color:#666">1</span>  
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">while</span> low <span style="color:#666">&lt;</span> high:  
</span></span><span style="display:flex;"><span>        <span style="color:#080;font-style:italic"># 核心：计算mid公式  </span>
</span></span><span style="display:flex;"><span>        mid <span style="color:#666">=</span> low <span style="color:#666">+</span> (high <span style="color:#666">-</span> low) <span style="color:#666">*</span> (key <span style="color:#666">-</span> arr[low]) <span style="color:#666">/</span> (arr[high] <span style="color:#666">-</span> arr[low])  
</span></span><span style="display:flex;"><span>        <span style="color:#a2f">print</span>(<span style="color:#b44">&#34;mid = </span><span style="color:#b68;font-weight:bold">{mid}</span><span style="color:#b44">, low = </span><span style="color:#b68;font-weight:bold">{low}</span><span style="color:#b44">, high = </span><span style="color:#b68;font-weight:bold">{high}</span><span style="color:#b44">&#34;</span><span style="color:#666">.</span>format(mid <span style="color:#666">=</span> mid, low <span style="color:#666">=</span> low, high <span style="color:#666">=</span> high))  
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span> key <span style="color:#666">&lt;</span> arr[mid]:  
</span></span><span style="display:flex;"><span>            high <span style="color:#666">=</span> mid <span style="color:#666">-</span> <span style="color:#666">1</span>  
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">elif</span> key <span style="color:#666">&gt;</span> arr[mid]:  
</span></span><span style="display:flex;"><span>            low <span style="color:#666">=</span> mid <span style="color:#666">+</span> <span style="color:#666">1</span>  
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">else</span>:  
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">return</span> mid  
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span> key <span style="color:#666">&lt;</span> arr[low] <span style="color:#a2f;font-weight:bold">or</span> key <span style="color:#666">&gt;</span> arr[high]:  
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">break</span>  
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f;font-weight:bold">None</span>  
</span></span></code></pre></div><h2 id="分析-1">分析</h2>
<p>时间复杂性：如果元素均匀分布，则O(log(logn))，在最坏的情况下可能需要 O(n)。<br>
空间复杂度：O(1)。<br>
对增量均匀的查找速度更快。</p>
<h1 id="哈希查找">哈希查找</h1>
<h2 id="思想-3">思想</h2>
<p>通过hash函数，实现O(1)的查找。如输入5，通过函数直接返回2。<br>
哈希需要遵循两个规则：<br>
(1) Key尽可能分散，避免多个Key指向同一个值。<br>
(2) 哈希函数尽可能简单，避免造成资源浪费在哈希函数上。</p>
<p>常用哈希算法：<br>
(1) 直接定址法：key=Value+C；这个“C&quot;是常量。Value+C其实就是一个简单的哈希函数。<br>
(2) 除法取余法：key=value%C；<br>
(3) 数字分析法：比如有一组value1=112233，value2=112633，value3=119033，针对这样的数我们分析数中间两个数比较波动，其他数不变。那么我们取key的值就可以是key1=22,key2=26,key3=90。<br>
(4) 平方取中法。<br>
(5) 折叠法：比如value=135790，要求key是2位数的散列值。那么我们将value变为13+57+90=160，然后去掉高位“1”,此时key=60，哈哈，这就是他们的哈希关系，这样做的目的就是key与每一位value都相关，来做到“散列地址”尽可能分散的目地。</p>
<p>冲突解决办法：<br>
(1) 开放地址法：其实就是数组中未使用的地址。也就是说，在发生冲突的地方，后到的那个元素（可采用两种方式:线性探测，函数探测）向数组后寻找&quot;开放地址“然后把自己插进入。<br>
(2) 链接法：在每个元素上放一个”指针域“，在发生冲突的地方，后到的那个元素将自己的数据域抛给冲突中的元素，此时冲突的地方就形成了一个链表。</p>
<h2 id="实现-2">实现</h2>
<p>设计函数采用：”除法取余法“。<br>
冲突方面采用:”开放地址线性探测法&quot;。</p>
<h3 id="todo">TODO</h3>
<h2 id="分析-2">分析</h2>
<h1 id="索引查找">索引查找</h1>
<h1 id="二叉排序树">二叉排序树</h1>
<h2 id="思想-4">思想</h2>
<p>树的定义：若根节点有左子树，则左子树的所有节点都比根节点小；若根节点有右子树，则右子树的所有节点都比根节点大，如图：</p>
<p><img src="/self/img/2019/08/1276987458.png" alt="二叉树.png"></p>
<h3 id="插入数据">插入数据</h3>
<p>如插入3到这颗树中：<br>
3比6小，3与6的左子树比较；<br>
3比4小，3与4的左子树比较；<br>
3比2大，将3插入2的右子树。</p>
<p><img src="/self/img/2019/08/561276523.png" alt="二叉树2.png"></p>
<h3 id="查找数据">查找数据</h3>
<p>按照插入数据的逻辑查找即可。</p>
<h3 id="删除数据">删除数据</h3>

    
  </article>
  <div class="paginator">
    
    <a class="link" href="https://mwflower.github.io/post/young/">← prev</a>
    
    
    <a class="link" href="https://mwflower.github.io/post/sudongpo/">next →</a>
    
  </div>
  <div class="comment">
    
    
    
    
    
    
  </div>
  
</main>

    <header id="header">
  <nav>
    
    <span class="nav-bar-item">
      <a class="link" href="/post/">Archives</a>
    </span>
    
    <span class="nav-bar-item">
      <a class="link" href="/run/">Run</a>
    </span>
    
    <span class="nav-bar-item">
      <a class="link" href="/gallery/">Beauty</a>
    </span>
    
    <span class="nav-bar-item">
      <a class="link" href="/box/">Box</a>
    </span>
    
    <span class="nav-bar-item">
      <a class="link" href="/station/">Station</a>
    </span>
    
    <span class="nav-bar-item">
      <a class="link" href="/search/">Search</a>
    </span>
    
  </nav>
</header>
<footer id="footer">
  <div>
    <span>© 2024</span> - <span>2024</span>
  </div>

  

  <div class="footnote">
    <span>Welcome
</span>
  </div>
</footer>

  </div>

  
  

  
  

  
  

</body>

</html>
