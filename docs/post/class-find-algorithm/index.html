<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>经典查找算法  - RUN SUN</title>
    
    
    <meta content="draft, study" name="keywords">
    
    <meta content="RUN SUN - 概述 线性查找分为顺序查找和二分查找。
查找有两种形态，破坏性查找和非破坏性查找，非破坏性查找不会改变数据结构。
顺序查找 思想 从头到尾顺序遍历一遍，很简单直接的方法。
二分查找 思想 假设一个从小到大的有序序列，取中间值和目标比较，如果中间值大，则下一步比较中间值之前的序列，否则比较中间值之后的序列。依次循环，直到找到目标值或遍历结束。
实现 def bin_search(arr, key): low, high = 0, len(arr) - 1 while low &lt; high: mid = (low &#43; high) / 2 print(&#34;mid = {mid}, low = {low}, high = {high}&#34;.format(mid = mid, low = low, high = high)) if key &lt; arr[mid]: high = mid - 1 elif key &gt; arr[mid]: low = mid &#43; 1 else: return mid if key &lt; arr[low] or key &gt; arr[high]: break return None 分析 有序序列时间复杂度为O(nlogn)；" name="description">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    
    

    

    

    

    <link rel="stylesheet" href="/layui/css/layui.css">
    <link rel="stylesheet" href="/self/css/default.css">
    <script src=" /layui/layui.js"></script>

    <link rel="stylesheet" async href="/self/css/markdown.min.css">
    <link rel="stylesheet" async href="/self/css/gallery.css">
    
    
    

    <script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin="anonymous">
    <script async src="https://cdn.jsdelivr.net/npm/lazysizes@5.2.0/lazysizes.min.js" integrity="sha256-h2tMEmhemR2IN4wbbdNjj9LaDIjzwk2hralQwfJmBOE=" crossorigin="anonymous"></script></head>

<body>
    
    <header class="layui-header layui-bg-cyan">
    <div class="layui-container">
        
        
        <a class="nav-self-logo" href="/">
            RUN SUN
        </a>

        <ul class="layui-nav layui-layout-right layui-bg-cyan" lay-filter="">
            
            
            <li class="layui-nav-item" id="nav_big"><a href="/categories/">Base</a></li>
            

            
                
                    <li class="layui-nav-item" id="nav_big"><a href="/run/">Run</a></li>
                
                    <li class="layui-nav-item" id="nav_big"><a href="/gallery/">Beauty</a></li>
                
                    <li class="layui-nav-item" id="nav_big"><a href="/box/">Box</a></li>
                
                    <li class="layui-nav-item" id="nav_big"><a href="/station/">Station</a></li>
                
                    <li class="layui-nav-item" id="nav_big"><a href="/search/">Search</a></li>
                
            

            
            <li class="layui-nav-item" id="nav_small">
                <a href="javascript:;">
                    <i class="layui-icon layui-icon-app" style="font-size: 24px;"></i>
                </a>

                <dl class="layui-nav-child">
                    
                    <dd><a href="/categories/">Base</a></dd>
                    

                    
                        
                            <dd><a href="/run/">Run</a></dd>
                        
                            <dd><a href="/gallery/">Beauty</a></dd>
                        
                            <dd><a href="/box/">Box</a></dd>
                        
                            <dd><a href="/station/">Station</a></dd>
                        
                            <dd><a href="/search/">Search</a></dd>
                        
                    
                </dl>
            </li>
        </ul>
    </div>
</header>

<script>
layui.use('element', function(){
  var element = layui.element;
});
</script>

        <div id="content" style="min-height:80%">
<div class="layui-container" style="margin-bottom: 10px">
    

    <div class="layui-row layui-col-space10">
        <div class="layui-card single-card">
            <br />
            <div class="markdown-body single-title" >
                <h1>经典查找算法</h1>
                <div style="margin-top:10px; margin-bottom:10px"> 
    
        <span>2019-08-06</span>

        

        
            <span style="margin-left: 20px;"></span>
        
        
            <a href="/categories/study/">
                <span class="layui-badge layui-bg-orange" style="vertical-align: 2px;">study</span>
            </a>
        
    
</div>

            </div>
            <div class="layui-card-body markdown-body single-content">
                <h1 id="概述">概述</h1>
<p>线性查找分为顺序查找和二分查找。<br>
查找有两种形态，破坏性查找和非破坏性查找，非破坏性查找不会改变数据结构。</p>
<h1 id="顺序查找">顺序查找</h1>
<h2 id="思想">思想</h2>
<p>从头到尾顺序遍历一遍，很简单直接的方法。</p>
<h1 id="二分查找">二分查找</h1>
<h2 id="思想-1">思想</h2>
<p>假设一个从小到大的有序序列，取中间值和目标比较，如果中间值大，则下一步比较中间值之前的序列，否则比较中间值之后的序列。依次循环，直到找到目标值或遍历结束。</p>
<h2 id="实现">实现</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">bin_search</span>(arr, key):  
</span></span><span style="display:flex;"><span>    low, high <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, len(arr) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> low <span style="color:#f92672">&lt;</span> high:  
</span></span><span style="display:flex;"><span>        mid <span style="color:#f92672">=</span> (low <span style="color:#f92672">+</span> high) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>  
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;mid = </span><span style="color:#e6db74">{mid}</span><span style="color:#e6db74">, low = </span><span style="color:#e6db74">{low}</span><span style="color:#e6db74">, high = </span><span style="color:#e6db74">{high}</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">.</span>format(mid <span style="color:#f92672">=</span> mid, low <span style="color:#f92672">=</span> low, high <span style="color:#f92672">=</span> high))  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> key <span style="color:#f92672">&lt;</span> arr[mid]:  
</span></span><span style="display:flex;"><span>            high <span style="color:#f92672">=</span> mid <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">elif</span> key <span style="color:#f92672">&gt;</span> arr[mid]:  
</span></span><span style="display:flex;"><span>            low <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:  
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> mid  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> key <span style="color:#f92672">&lt;</span> arr[low] <span style="color:#f92672">or</span> key <span style="color:#f92672">&gt;</span> arr[high]:  
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">None</span>  
</span></span></code></pre></div><h2 id="分析">分析</h2>
<p>有序序列时间复杂度为O(nlogn)；<br>
无序序列时间复杂度为排序+查找=O(nlogn)+O(nlogn)，最快的排序算法时间复杂度为O(nlogn)；<br>
只适用于线性结构的数据。</p>
<h1 id="插值查找">插值查找</h1>
<h2 id="思想-2">思想</h2>
<p>核心在于插值的计算公式 (key-a[low])/(a[high]-a[low])*(high-low)。<br>
基于二分查找，将查找点的选择改进为自适应选择，可以提高查找效率，也属于有序查找。<br>
对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。</p>
<h2 id="实现-1">实现</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">insert_search</span>(arr, key):  
</span></span><span style="display:flex;"><span>    low, high <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, len(arr) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> low <span style="color:#f92672">&lt;</span> high:  
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 核心：计算mid公式  </span>
</span></span><span style="display:flex;"><span>        mid <span style="color:#f92672">=</span> low <span style="color:#f92672">+</span> (high <span style="color:#f92672">-</span> low) <span style="color:#f92672">*</span> (key <span style="color:#f92672">-</span> arr[low]) <span style="color:#f92672">/</span> (arr[high] <span style="color:#f92672">-</span> arr[low])  
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;mid = </span><span style="color:#e6db74">{mid}</span><span style="color:#e6db74">, low = </span><span style="color:#e6db74">{low}</span><span style="color:#e6db74">, high = </span><span style="color:#e6db74">{high}</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">.</span>format(mid <span style="color:#f92672">=</span> mid, low <span style="color:#f92672">=</span> low, high <span style="color:#f92672">=</span> high))  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> key <span style="color:#f92672">&lt;</span> arr[mid]:  
</span></span><span style="display:flex;"><span>            high <span style="color:#f92672">=</span> mid <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">elif</span> key <span style="color:#f92672">&gt;</span> arr[mid]:  
</span></span><span style="display:flex;"><span>            low <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:  
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> mid  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> key <span style="color:#f92672">&lt;</span> arr[low] <span style="color:#f92672">or</span> key <span style="color:#f92672">&gt;</span> arr[high]:  
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">None</span>  
</span></span></code></pre></div><h2 id="分析-1">分析</h2>
<p>时间复杂性：如果元素均匀分布，则O(log(logn))，在最坏的情况下可能需要 O(n)。<br>
空间复杂度：O(1)。<br>
对增量均匀的查找速度更快。</p>
<h1 id="哈希查找">哈希查找</h1>
<h2 id="思想-3">思想</h2>
<p>通过hash函数，实现O(1)的查找。如输入5，通过函数直接返回2。<br>
哈希需要遵循两个规则：<br>
(1) Key尽可能分散，避免多个Key指向同一个值。<br>
(2) 哈希函数尽可能简单，避免造成资源浪费在哈希函数上。</p>
<p>常用哈希算法：<br>
(1) 直接定址法：key=Value+C；这个“C&quot;是常量。Value+C其实就是一个简单的哈希函数。<br>
(2) 除法取余法：key=value%C；<br>
(3) 数字分析法：比如有一组value1=112233，value2=112633，value3=119033，针对这样的数我们分析数中间两个数比较波动，其他数不变。那么我们取key的值就可以是key1=22,key2=26,key3=90。<br>
(4) 平方取中法。<br>
(5) 折叠法：比如value=135790，要求key是2位数的散列值。那么我们将value变为13+57+90=160，然后去掉高位“1”,此时key=60，哈哈，这就是他们的哈希关系，这样做的目的就是key与每一位value都相关，来做到“散列地址”尽可能分散的目地。</p>
<p>冲突解决办法：<br>
(1) 开放地址法：其实就是数组中未使用的地址。也就是说，在发生冲突的地方，后到的那个元素（可采用两种方式:线性探测，函数探测）向数组后寻找&quot;开放地址“然后把自己插进入。<br>
(2) 链接法：在每个元素上放一个”指针域“，在发生冲突的地方，后到的那个元素将自己的数据域抛给冲突中的元素，此时冲突的地方就形成了一个链表。</p>
<h2 id="实现-2">实现</h2>
<p>设计函数采用：”除法取余法“。<br>
冲突方面采用:”开放地址线性探测法&quot;。</p>
<h3 id="todo">TODO</h3>
<h2 id="分析-2">分析</h2>
<h1 id="索引查找">索引查找</h1>
<h1 id="二叉排序树">二叉排序树</h1>
<h2 id="思想-4">思想</h2>
<p>树的定义：若根节点有左子树，则左子树的所有节点都比根节点小；若根节点有右子树，则右子树的所有节点都比根节点大，如图：</p>
<p><img src="/self/img/2019/08/1276987458.png" alt="二叉树.png"></p>
<h3 id="插入数据">插入数据</h3>
<p>如插入3到这颗树中：<br>
3比6小，3与6的左子树比较；<br>
3比4小，3与4的左子树比较；<br>
3比2大，将3插入2的右子树。</p>
<p><img src="/self/img/2019/08/561276523.png" alt="二叉树2.png"></p>
<h3 id="查找数据">查找数据</h3>
<p>按照插入数据的逻辑查找即可。</p>
<h3 id="删除数据">删除数据</h3>
</div>
        </div>
    </div>
</div>


        </div><footer>
    
    
    <div class="layui-container">
        <p class="copyright">RUN SUN</p>
    </div>
</footer>

</body>
</html>
